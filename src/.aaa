#include "frame_combiner.hpp"
#include <algorithm>
#include <filesystem>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>

extern "C" {
#include <libavcodec/avcodec.h>
#include <libavcodec/packet.h>
#include <libavformat/avformat.h>
#include <libavutil/frame.h>
#include <libavutil/imgutils.h>
#include <libavutil/samplefmt.h>
#include <libswscale/swscale.h>
}

FrameCombiner::FrameCombiner(const std::string &output_dir)
    : output_dir(output_dir), frames(), files() {
  std::vector<std::string> png_files;

  // Iterate over the directory contents
  for (const auto &entry : std::filesystem::directory_iterator(output_dir)) {
    // Check if the file extension is .png
    if (entry.path().extension() == ".png") {
      // Add the file path to the vector
      png_files.push_back(entry.path().string());

      std::cout << "Found: " << png_files.back() << std::endl;
    }
  }
  files = png_files;

  // Convert PNG files to AVFrames
  for (const auto &file : png_files) {
    // Open the PNG file using FFmpeg's avformat
    AVFormatContext *format_ctx = nullptr;
    if (avformat_open_input(&format_ctx, file.c_str(), nullptr, nullptr) != 0) {
      std::cerr << "Failed to open file: " << file << std::endl;
      continue;
    }

    // Retrieve stream information
    if (avformat_find_stream_info(format_ctx, nullptr) < 0) {

      std::cerr << "Failed to find stream information for file: " << file
                << std::endl;

      avformat_close_input(&format_ctx);
      continue;
    }

    // Find the first video stream
    int video_stream_index =
        av_find_best_stream(format_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, nullptr, 0);
    if (video_stream_index == -1) {
      std::cerr << "No video stream found in file: " << file << std::endl;
      avformat_close_input(&format_ctx);
      continue;
    }

    // Create a codec context from the stream
    AVCodecParameters *codec_par =
        format_ctx->streams[video_stream_index]->codecpar;

    AVCodec *codec =
        const_cast<AVCodec *>(avcodec_find_decoder(codec_par->codec_id));
    if (!codec) {
      std::cerr << "Failed to find decoder for file: " << file << std::endl;
      avformat_close_input(&format_ctx);
      continue;
    }

    AVCodecContext *codec_ctx = avcodec_alloc_context3(codec);

    if (!codec_ctx) {
      std::cerr << "Failed to allocate codec context for file: " << file
                << std::endl;

      avformat_close_input(&format_ctx);
      continue;
    }

    if (avcodec_parameters_to_context(codec_ctx, codec_par) < 0) {

      std::cerr << "Failed to fill codec context for file: " << file
                << std::endl;
      avcodec_free_context(&codec_ctx);
      avformat_close_input(&format_ctx);
      continue;
    }

    // Open the codec for the video stream
    if (avcodec_open2(codec_ctx, codec, nullptr) < 0) {
      std::cerr << "Failed to open decoder for file: " << file << std::endl;
      avcodec_free_context(&codec_ctx);
      avformat_close_input(&format_ctx);
      continue;
    }

    // Read frames from the video stream and store them in the vector
    AVPacket *packet = av_packet_alloc();
    AVFrame *frame = av_frame_alloc();
    if (!frame) {
      std::cerr << "Failed to allocate AVFrame for file: " << file << std::endl;
      avcodec_close(codec_ctx);

      avcodec_free_context(&codec_ctx);

      avformat_close_input(&format_ctx);
      continue;

      // Variables for timestamp calculation
      int64_t curr_pts = 0;
      AVRational time_base = format_ctx->streams[video_stream_index]->time_base;

      while (av_read_frame(format_ctx, packet) >= 0) {
        if (packet->stream_index == video_stream_index) {
          if (avcodec_send_packet(codec_ctx, packet) < 0) {

            std::cerr << "Error sending packet for file: " << file << std::endl;
            break;
          }

          while (avcodec_receive_frame(codec_ctx, frame) >= 0) {
            // Set the frame timestamp based on the current PTS and time base
            frame->pts = curr_pts++;
            // Convert the frame timestamp to seconds
            // double timestamp = av_q2d(time_base) * frame->pts;
            frames.push_back(frame);
          }
        }

        av_packet_unref(packet);
      }

      av_frame_free(&frame);
      avcodec_close(codec_ctx);
      avcodec_free_context(&codec_ctx);
      avformat_close_input(&format_ctx);
    }
  }
}

FrameCombiner::~FrameCombiner() {
  for (auto frame : frames) {
    av_frame_free(&frame);
  }
}

void FrameCombiner::combine_frames_to_video(const std::string &output_video) {
}
